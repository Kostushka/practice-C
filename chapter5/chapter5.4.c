#include <stdio.h>
#define MAX 100

// 5.4 Адресная арифметика

// если указатели указывают на элементы одного массива, их можно сравнивать < <= >=  > == != и вычитать
// q - p + 1 // кол-во элементов от q до p включительно

// указатели можно складывать с целыми числами p + 5 => адрес + 5 => n[0] -> n[5]
// переход к соответствующему элементу происходит независимо от типа данных

// указателю можно присваивать 0 и сравнивать с 0

// разрешено присваивание указателей одного типа


// strlen с использованием адресной арифметики
int strlenp (char *);

// возвращает указатель на n последовательно идущих ячеек памяти длинной один символ
char* alloc (int n);
// записываем аргумент в указатель на свободный элемент
void afree (char *);

static char allocbuf[MAX]; // буфер памяти, куда мы с использованием указателя записываем что-то или который мы очищаем
static char *allocp = allocbuf; // указатель на следующий свободный элемент 
								// static char *allocp = &allocbuf[0]; (имя массива == адрес его нулевого элемента)

int main (void) {
	char s[] = "Hello, friends!";
	printf("%d\n", strlenp(s));
	
	return 0;
}

char* alloc (int n) {
	// есть ли место в массиве для n элементов: 100 - 5 >= 10
	if (allocbuf + MAX - allocp >= n) {
		// записываем адрес следующего свободного элемента
		allocp += n;
		// возвращает указатель на n последовательно идущих ячеек
		return allocp - n;
	} else {
		return 0;
	}
}

void afree (char *p) {
	// если p указывает на элемент в диапозоне адресов элементов массива
	if (p >= allocbuf && p < allocbuf + MAX) {
		// записываем p в указатель на свободный элемент
		allocp = p;
	}
}

int strlenp (char *s) {
	// два указателя на нулевой элемент массива
	char *p = s;
	// сдвигаем адрес в p
	while (*p != '\0') {
		++p;
	}
	// вычитаем из адреса последнего элемента + 1 адрес первого элемента
	return p - s;
}
