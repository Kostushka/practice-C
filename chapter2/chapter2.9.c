#include <stdio.h>

// 2.9 Поразрядные операции

unsigned getbits (unsigned x, int p, int n);

int main (void) {
    unsigned int a;
    unsigned char b;
    unsigned int c;
    signed char d;

    char m;
    m = 044; // 100100 - из 8ричной системы в 2чную
    m = m & ~07; // ~111 => 000 - последние три разряда числа в ноль
    // ожидаем 100000 - 20 в 16ричной
    				 // 40 в 8ричной
    				 // 32 в 10ричной
    printf("%x %o %d\n", m, m, m);
    
    a = ~0; // поразрядно инвертируем 0: 32 бита - 1111 1111 1111 1111 1111 1111 1111 1111

    b = 3; // 8 бит - 0000 0011
    b = ~b; // поразрядно инвертируем 1111 1100 == FC

    printf("%u\n", a);
    printf("%x\n", b);

    c = 0xFFFFFFFa; // 1111 1111 1111 1111 1111 1111 1111 1010

    c = ~c; // 0000 0000 0000 0000 0000 0000 0000 0101 == 5
    printf("%d\n", c);

    c = c & 0b100;
    printf("%d\n", c); // 0000 0000 0000 0000 0000 0000 0000 0100 == 4

    c = c | 0b111;
    printf("%d\n", c); // 0000 0000 0000 0000 0000 0000 0000 0111 == 7 

    c = c ^ 0b1111;
    printf("%d\n", c); // 0000 0000 0000 0000 0000 0000 0000 1000 == 8 

    int x = 8; // 1000
    int y = 10; // 1010
    x = x ^ y; // 0010

    y = y ^ x; // 1000
    x = x ^ y; // 1010
    printf("x: %d y: %d\n", x, y);
    

    // логический сдвиг - для целых неотрицательных чисел

    // << побитовый сдвиг влево
    // << 1 == умножение на 2
    // << 2 == умножение на 4
    // << 3 == умножение на 8
    // << 8 == умножение на 256
    // работает быстрее умножения
    c = c << 8;
    printf("%d\n", c); // 0000 0000 0000 0000 0000 1000 0000 0000 ==  8 0 0 == 2048
    // >> побитовый сдвиг вправо
    // >> 1 == деление на 2
    // >> 2 == деление на 4
    // >> 3 == деление на 8
    // >> 4 == деление на 16
    c = c >> 4;
    printf("%d\n", c); // 0000 0000 0000 0000 0000 0000 1000 0000 ==  8 0 == 128
    // 0111 1111 == 2^7: 0 - 127
    // 1000 0000 == 128

    // арифметический сдвиг вправо!! - для целых чисел с учетом знака (добавление 1 вместо 0)
    d = 8; // 0000 1000
    d = 255; // 1111 1111
    d = -1; // 1111 1111

    d = -8; // 1111 1000
    d = d >> 2; // 1111 1110 == -2
    printf("%d\n", d); 
    
	// позиции: 6543210
	//          1110101
	// нас интересует три бита: 2 3 4
	// сдвиг: выравнивание по правому краю (4 + 1 - 3)
	// 			0011101
	// единицы для сравнения 11111111 -> 11111000 -> 00000111
	// сравнение
	// 			0011101
	// 			0000111
	// результат
	// 101
	
    printf("%d\n", getbits(0b1110101, 4, 3));
 
}

// извлекает n бит, начиная с позиции p
unsigned getbits (unsigned x, int p, int n) {

	return (x >> (p + 1 - n)) & ~(~0 << n);
}
